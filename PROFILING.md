# Stage 3 - Асинхронный сервер
* Теперь задачи работы с сокетом и задачи работы с хранилищем разделены
* Запросы к /status работают быстрее и не ждут пока выполнятся другие запросы, связанные с хранилищем

## GET
### CPU
Селекторы теперь только разгребают запросы и ставят задачи в очередь, а работу с хранилищем и ответом занимаются воркеры
### ALLOC
Больше всего памяти выделяется воркерами при запросах к хранилищу
### LOCK
Методы `sendResponse` и `sendError` у `HttpSession` - synchronized, на них и локи

## PUT
### CPU
На работу с сокетом времени тратится больше, чем непосредственно на саму вставку
### ALLOC
Аналогично GET, большая часть памяти выделяется на вставку в хранилище
### LOCK
Блокировки опять же в synchronized методах `HttpSession`

# Stage 4 - Шардирование
Порядок выполнения профилирования - 3 раза стреляем PUT'ами по одним и тем же ключам, после этого, без перезапуска сервера, стреляем GET'ами по тем же ключам (т.е. база не пустая).
* Было замечено, что с использованием внутреннего пула воркеров one-nio тайминги значительно больше, чем при использовании `FixedThreadPool`, в связи с чем было принято решение отказаться от пула one-nio. Так, если раньше 100% запросов при стрельбе put'ами занимали **23ms**, теперь занимают **15ms**. Get - **18ms** раньше против **8ms** сейчас.  
* На стандартном one-nio пуле воркеров при профилировании `LockSupport.park()` занимал **50%** времени CPU. При переходе на `FixedThreadPool` это время снизилось до **15%**.
* Так же, при стрельбе запросами при тех же условиях, что и раньше, таймаутов теперь нет.
## PUT
### CPU
Почти 13% времени занимает проксирование запроса к другой ноде, а вот непосредственно вставка в хранилище - всего 3%. Но ничего не поделать. 
### ALLOC
Так же, как и с CPU, немало памяти теперь выделяется при проксировании запроса (а именно при чтении с `HttpClient`'а). Да и в целом, можно заметить, что в основном память выделяется при работе с сетью, что, в общем-то, логично.
### LOCK
Как и в прошлом этапе, все локи - это методы `sendResponse` и `sendError` у `HttpSession`.
## GET
### CPU
Так же, как и в PUT - часть времени уходит на проксирование. На непосредственное взятие записи из базы - 3% (ключи в RAM).
### ALLOC
Теперь к аллокациям добавилось проксирование - и памяти для нее аллоцируется почти столько же, сколько используется при взятии значения из хранилища.
### LOCK
То же самое, что и при PUT'ах - методы `HttpSession`.