# Нагрузочное тестирование с Яндекс.Танком
Во время тестирования было обнаружено, что компьютер не справляется нормально с одновременно работающими сервером и танком, перегревается и начинает троттлить. Например, если стрелять уникальными PUTами тем же wrk2 с такими же ключами, такой же длиной value в 256 байт, то сервер без проблем держит **2000** rps (а может и больше, не проверял) в течение двух минут. Однако при стрельбе танком из-за троттлинга даже при 1000 rps периодически сбрасываются частоты.  
В связи c этим было принято решение подбирать такой rps, при котором система не будет перегреваться, и тест будет проходить более стабильно.
## Подготовка
Были написаны два генератора. Первый - [генератор патронов](https://github.com/rubtsovnyu/2019-highload-dht/blob/stage-7/src/main/java/ru/mail/polis/service/rubtsov/tank/AmmoGenerator.java). На вход подается режим (`mode`), который зависит от требуемой ленты, и количество запросов. Второй - [генератор конфигов](https://github.com/rubtsovnyu/2019-highload-dht/blob/stage-7/src/main/java/ru/mail/polis/service/rubtsov/tank/ConfigGenerator.java), был сделан просто для удобства.
## Лента с PUTами с уникальными ключами
* `AmmoGenerator` создает ленту из последовательных PUTов с ключами от 0 до [количество запросов].
* Далее [обстреливаем](https://overload.yandex.net/229289) линейно-возрастающей нагрузкой от 0 до 5000 rps.
* Примерно на 1.5к rps все становится очень плохо. Тестировал постепенно от 1к rps до 500 rps с шагом 100, при 500 rps система почти не троттлила, поэтому было выбрано именно это значение.
* [Результаты](https://overload.yandex.net/229954). В целом, неплохие тайминги. Среднее время - 1ms, 99 перцентиль 4мс, работает все стабильно, периодические всплески связаны, скорее всего, с троттлингом. Вряд ли это из-за флашей, так как количество вспелсков просто не соответствовало количеству флашей.
## Лента с PUTами с частичной перезаписью ключей (вероятность 10%)
* `AmmoGenerator` создает ленту из последовательных путов, на каждой итерации берет Random.nextLong(10), и если он == 0, то мы оверврайтим рандомный ключ из тех, что уже добавили.
* [Так же](https://overload.yandex.net/229469), на 1.5к rps все становится плохо, итоговый более-менее стабильный rps был выбран 600.
* [Результаты](https://overload.yandex.net/229485). 99 персентиль 18ms, среднее время - 2.46 мс. Менее стабильно, чем в первом режиме - был всплеск, скорее всего просто 600 rps потяжелее, чем 500 (как в первом режиме), и я снова словил троттлинг.
## Лента с GETами существующих ключей с равномерным распределением (стреляем по наполненной БД)
* Сначала с использованием патронов из первого режима [были залиты](https://overload.yandex.net/229813) под 1k rps 265,370 значений. После, с помощью `AmmoGenerator` были созданы патроны по этим ключам с равномерным распределением (`Random.nextLong(keyCount)`).
* [Так же](https://overload.yandex.net/229816), после тысячи стало тяжеловато, на 1.5к совсем грустно (на 3.5к кстати можно заметить как тачке стало уж совсем жарко). После кучи тестов был определен более-менее оптимальный rps 400.
* [Результаты](https://overload.yandex.net/229859). Хорошо и стабильно, 99 перцентиль 5ms - хорошо для GETов, среднее время - 1.56ms, большинство запросов были обработаны за 1.11ms.
## GETы со смещением распределения к недавно добавленным ключам
* Сначала, как и в предыдущем этапе, [заполняем](https://overload.yandex.net/229866) базу ключами, всего получилось 266,723 ключей. После этого `AmmoGenerator`ом патроны запросы с помощью `Random.nextGaussian([последний добавленный ключ])`.
* После тысячи тяжело, 1200 уже прям плоховато, дальше грустно. Были выбраны 800 и 400 rps.
* В ходе определения стабильных rps были использованы различные значения. [800 rps](https://overload.yandex.net/229859) - неплохо продержался, 99 перцентиль 5ms, среднее время 1.5ms (как и в предыдущем этапе, однако с в два раза большим количеством rps).
* Как стабильный был выбран [400 rps](https://overload.yandex.net/229891). 99 перцентиль - 4ms, 99.9 - 11ms, среднее время 1.38ms. Лучше, чем при стрельбе с равномерным распределением ключей, но ненамного - буст в основном получился только из за тех ключей, которые лежат в `MemTable` (или же это вообще статистическая погрешность). Для того, чтобы увидеть реальное отличие, необходимо заполнять хранилище куда большим количеством ключей, тогда работа с последними ключами действительно будет намного быстрее, чем со старыми.
## Лента со смешанной нагрузкой с 50% PUTы новых ключей и 50% GETы существующих ключей (равномерное распределение)
* `AmmoGenerator` последовательно равновероятно выбирает, что сейчас будет - PUT нового ключа или GET старого. Опционально можно было сначала заполнить базу просто PUTами ключей, а потом уже указать `AmmoGenerator`у, с какого ключа стартовать PUTы, но я просто запустил с нуля.
* Искал максимальный стабильный rps [тут](https://overload.yandex.net/229912). На тысяче стало тяжело, 1300 совсем тяжело, дальше грустно. В поисках были перепробованы куча значений, даже на [500 rps](https://overload.yandex.net/229930) был троттлинг, в итоге более-менее стабильной система стала на 400 rps.
* На 400 rps система вела себя достаточно стабильно, большинство запросов были обработаны за 0.84ms, среднее время - 1.376ms, среднее время GETа - 1.395ms, PUTа - 1.357ms. 99 перцентиль - 5ms у обоих методов, 99.9 - 48ms. В целом стабильное поведение.
## Выводы
Сервер может стабильно работать при определенных нагрузках длительное время. Увы, из-за троттлинга получить хорошие цифры не удалось, и во всех тестах использовались малые значения rps. 
